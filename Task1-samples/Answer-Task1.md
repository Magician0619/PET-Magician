==闪烁脉冲信号处理任务==
> 数据下载地址：链接: https://pan.baidu.com/s/1vlh6rLdmQAU_ePxIN7blDg  密码: flch
> 
> 数据的电压采样阈值为：V1=40、V2=110、V3=180、V4=270

[TOC]

# 一、读取二进制Samples文件

.samples文件是二进制的文件，可以使用python的BufferedIOBase.read(size: int) -> bytes函数进行读取。这里面，我们定义每一个事件为544bits，为一帧。将数据提取出来之后，利用unpack函数进行解包。

$$544 = 16*2+64*8$$

```python
struct.unpack('<hhdddddddd', binf_single)
```

![image](https://s1.ax1x.com/2020/09/23/wxQVv4.png)

由于`6BDM.samples`文件过大，所以我们只对前10帧数据进行提取观察,可以得到以下的数据

|  nB | nC | T1 |    T2    |    T3    |    T4    |    T5    |    T6    |    T7    |    T8    |
|:---:|:--:|:--:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 132 | 36 |  0 |  0.28302 | 0.943405 |  1.69812 | 37.64151 | 51.22643 | 66.32076 | 67.54718 |
| 132 | 55 |  0 | 0.471695 |  1.22641 |  1.4151  | 40.84906 | 55.94341 | 62.54716 | 86.13208 |
| 132 |  3 |  0 | 0.803574 | 1.339279 | 2.946426 | 18.66071 | 42.05357 | 51.78571 | 64.91071 |
| 132 | 28 |  0 | 1.037735 |  2.07547 |  4.05661 | 23.49057 | 47.35849 | 57.73586 | 75.37737 |
| 132 |  5 |  0 | 0.535721 | 1.160721 | 1.964294 | 29.46429 |  33.125  | 62.05357 | 78.92857 |
| 132 | 21 |  0 | 0.446426 |   0.625  | 1.071426 | 40.26785 | 48.92857 | 59.91071 |   73.75  |
| 132 | 30 |  0 | 1.603775 |  2.45282 | 4.622635 | 35.75471 | 47.73584 | 56.03773 | 86.13206 |
| 132 |  5 |  0 | 0.357147 |   0.625  | 0.892853 | 44.01785 | 50.26785 | 52.41071 | 73.83928 |
| 132 | 50 |  0 |  0.84906 | 1.509445 |  2.54718 | 43.67924 | 52.35849 | 61.69812 | 83.39622 |
| 132 | 50 |  0 | 1.037735 | 1.886795 |  3.20755 | 37.54716 | 47.83018 | 62.16982 | 86.22641 |

# 二、对脉冲数据拟合曲线

从获得的数据里面，我们对第一帧数据绘制散点图可以得到以下图像，并且有一个大概的认识

![image](https://s1.ax1x.com/2020/09/23/wxQCEq.png)

这里面我们首先主要考虑`多项式拟合`、`双指数拟合`两种形式：

1. 多项式拟合

```python
poly = np.polyfit(x,y,5) 
```

![多项式曲线](https://s1.ax1x.com/2020/09/23/wxY1w4.png)

2. 双指数拟合

根据论文[《FPGA-Only MVT Digitizer for TOF PET》](http://ieeexplore.ieee.org/document/6589019/)中的双指数形式：

$$y(t)=a \times \exp \left(-\frac{t-t_{0}}{b}\right) \times\left[1-\exp \left(-\frac{t-t_{0}}{d}\right)\right]$$

我们假设函数形式为：

```python
def double_exp(x,a,b,d):
    """双指数函数
    参数:
    ------------
    x : float
        当前时间与脉冲发生时间的差值
    a : float
        由脉冲幅度决定
    b, d: float
        由脉冲的上升和下降时间决定
    """
    return  a*np.exp(b*(x))*(1-np.exp(d*(x)))
```

> 双指数函数的拟合过程：拟合时使用scipy模块的子模块optimize中提供的一个专门用于曲线拟合的函数curve_fit()。但是在拟合的时候还是发现了几个严重的问题，其中包括参数上下限的选取以及拟合次数的选择，这里面拟合是一个关键。

```python
bounds = ([-2,-2,0],[0,0,2])
popt, pcov = curve_fit(double_exp, x_dexp, y_dexp, bounds = bounds, maxfev=500000)
# popt, pcov = curve_fit(double_exp, x_dexp, y_dexp, maxfev=500000)

'''scipy模块的子模块optimize中提供的一个专门用于曲线拟合的函数curve_fit()
# 官方详解链接：https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy-optimize-curve-fit
# popt：阵列参数的最佳值，以使（扩展数据，*popt）-ydata平方残差之和最小。
# pcov：二维阵列popt的估计协方差，对角线提供参数估计的方差。
# perr = np.sqrt(np.diag(pcov))，使用perr计算参数的一个标准偏差误差。
# bounds：参数的上下限。默认为无边界。元组的每个元素必须是长度等于参数数的数组，或者是标量（在这种情况下，所有参数的界限都是相同的）。
# maxfev：拟合次数上限。
'''

print("所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt[0],popt[1],popt[2]))
```

为了调整参数范围，使用断言对参数进行观察调整

```python
def assert_popt(popt,bounds,num):
    '''检查拟合参数是否需要调整
    参数：
    --------
    popt：拟合得到的参数
    bounds：参数范围
    num：第num+1次拟合
    '''
    for i in range(3):
        assert (popt[i]!=bounds[0][i]), "参数%s下限值应该调整!!!\n第%d帧数据所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt_dict[i],num+1,popt[0],popt[1],popt[2])
        assert (popt[i]!=bounds[1][i]), "参数%s上限值应该调整!!!\n第%d帧数据所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt_dict[i],num+1,popt[0],popt[1],popt[2])
```

接着在对坐标进行插值处理后得到更加光滑的拟合曲线。

![双指数函数曲线](https://s1.ax1x.com/2020/09/27/0FeGIs.png)


# 三、计算每个脉冲事件的能量（脉冲积分）

可根据第二步中拟合出的脉冲波形所得到的脉冲函数，再对脉冲进行积分运算，求出脉冲所具有的能量。

对于积分有三种办法：
1. 蒙特卡洛积分法。在均匀分布的条件下，求取采样值对应的函数值，乘以上下限的差，得到矩形面积，对矩形面积求平均即是积分值。但是存在误差偏大的情况。
2. integrate(函数，（变量，下限， 上限）)。但是无法对指数函数积分
3. 使用Scipy下的integrate.quad()函数，只需给出函数的形式以及积分上下限，便可返回积分值与误差。

最终采用第三种办法，并利用`xlwt`库函数将积分值保存至`Excel`中，得到下表结果

|  nB | nC | T1 |    T2    |    T3    |    T4    |    T5    |    T6    |    T7    |    T8    |  Energy  |
|:---:|:--:|:--:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 132 | 36 |  0 |  0.28302 | 0.943405 |  1.69812 | 37.64151 | 51.22643 | 66.32076 | 67.54718 | 22804.16 |
| 132 | 55 |  0 | 0.471695 |  1.22641 |  1.4151  | 40.84906 | 55.94341 | 62.54716 | 86.13208 | 26281.84 |
| 132 |  3 |  0 | 0.803574 | 1.339279 | 2.946426 | 18.66071 | 42.05357 | 51.78571 | 64.91071 | 12758.97 |
| 132 | 28 |  0 | 1.037735 |  2.07547 |  4.05661 | 23.49057 | 47.35849 | 57.73586 | 75.37737 | 14829.62 |
| 132 |  5 |  0 | 0.535721 | 1.160721 | 1.964294 | 29.46429 |  33.125  | 62.05357 | 78.92857 | 16092.16 |
| 132 | 21 |  0 | 0.446426 |   0.625  | 1.071426 | 40.26785 | 48.92857 | 59.91071 |   73.75  | 29224.47 |
| 132 | 30 |  0 | 1.603775 |  2.45282 | 4.622635 | 35.75471 | 47.73584 | 56.03773 | 86.13206 | 18263.02 |
| 132 |  5 |  0 | 0.357147 |   0.625  | 0.892853 | 44.01785 | 50.26785 | 52.41071 | 73.83928 | 38517.08 |
| 132 | 50 |  0 |  0.84906 | 1.509445 |  2.54718 | 43.67924 | 52.35849 | 61.69812 | 83.39622 | 25921.93 |
| 132 | 50 |  0 | 1.037735 | 1.886795 |  3.20755 | 37.54716 | 47.83018 | 62.16982 | 86.22641 | 20565.32 |



# 四、画出事件能谱

在对绘制事件能谱前，考虑到极少一部分数据存在拟合失败导致积分值错误的情况，我们暂时考虑去除错误数据集或者使用积分平均值代替。

同时为了对积分情况进行检验，编写了integrate_debug.py文件，发现主要存在以下两种错误拟合情况。

1. 数据点时间坐标较集中

![662c62efd7e7563f2b83a64b2ae132d](https://gitee.com/magician0619/picgo/raw/master/Task1/662c62efd7e7563f2b83a64b2ae132d.png)

2. 数据点时间坐标较分散

![f9def4416f6007de79d4d5bee8c96af](https://gitee.com/magician0619/picgo/raw/master/Task1/f9def4416f6007de79d4d5bee8c96af.png)



可以利用生成的.xls文件对`65000`个能量积分值进行绘制直方图。

也可以直接将能量积分值追加列表绘制直方图。


[![能谱直方图](https://s1.ax1x.com/2020/09/30/0mGTHg.png)](https://imgchr.com/i/0mGTHg)

# 五、对能谱归一化

对能谱$S(t)$来说，设其中的最大值为$S_{max}$利用线性标准化进行归一化到511kev即：

$$S(t)_{normal} = S(t)\frac{511}{S_{max}}$$


在归一化后可以得到事件能谱图如下：

[![能谱归一化图](https://s1.ax1x.com/2020/09/30/0mGoDS.png)](https://imgchr.com/i/0mGoDS)


# 六、高斯拟合

使用高斯拟合函数进行拟合，可能存在单高斯、双高斯以及多高斯拟合的情况。

这里面我们先采取双高斯函数进行拟合
```python
def gaussian_2(x,*param):
    return param[0]*np.exp(-np.power(x - param[2], 2.) / (2 * np.power(param[4], 2.)))+\
           param[1]*np.exp(-np.power(x - param[3], 2.) / (2 * np.power(param[5], 2.)))
```

发现拟合结果存在两个明显的高斯峰。

[![高斯拟合图像](https://s1.ax1x.com/2020/09/30/0mGHEQ.png)](https://imgchr.com/i/0mGHEQ)

# 七、计算能量分辨率
探测器的能量分辨率（Energy resolution of a detector)，表示线性探测器区分被探测粒子能量的能力的一个量。能量分辨率的分子是全能峰的半宽度，分母是全能峰能量的期望值。

它可用下述方法表示：利用一个发射一种或多种单能粒子的辐射源照射探测器，得到包括一个或多个单能峰的能谱。该能谱中各种峰的半高宽的大小称为该探测器对这种辐射的能量分辨率。

> 若不能忽略除探测器以外的其它因素对半高宽的影响，则应以平方相减的方法扣除这部分的影响，求出真正的探测器的半高宽：其中一个为总的半高宽，另外一个为除探测器以外部分引起的半高宽；AEn为探测器引起的半高宽。为使所测得的半高宽结果可信，必须在所测谱线中保证半高宽所占道数大于5道。由于半高宽与辐射能量有直接关系，因此，在给定能量分辨率时必须给出所对应的辐射能量。并要保证被测辐射的能量基本上全都损耗在探测器灵敏体积内。

结合实际情况，我们发现能谱的两个峰里面左边那个峰是散射产生的峰，所以在计算能量分辨率的时候是要把左边这个峰去掉只用右边这个真实事件的峰来计算的，所以只需要对右边这个峰做高斯算半高全宽。

由于该数据是一个平板的数据，所以分辨率确实不会太高。最终结果为：42.590%






