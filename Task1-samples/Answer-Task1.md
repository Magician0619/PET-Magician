==闪烁脉冲信号处理任务==
> 数据下载地址：链接: https://pan.baidu.com/s/1vlh6rLdmQAU_ePxIN7blDg  密码: flch
> 
> 数据的电压采样阈值为：V1=40、V2=110、V3=180、V4=270

# 1、读取二进制Samples文件

.samples文件是二进制的文件，可以使用python的BufferedIOBase.read(size: int) -> bytes函数进行读取。这里面，我们定义每一个事件为544bits，为一帧。将数据提取出来之后，利用unpack函数进行解包。

544 = 

```python
struct.unpack('<hhdddddddd', binf_single)
```

![image](https://s1.ax1x.com/2020/09/23/wxQVv4.png)

由于`6BDM.samples`文件过大，所以我们只对前10帧数据进行提取,可以得到以下的数据

|  nB | nC | T1 |    T2    |    T3    |    T4    |    T5    |    T6    |    T7    |    T8    |
|:---:|:--:|:--:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 132 | 36 |  0 |  0.28302 | 0.943405 |  1.69812 | 37.64151 | 51.22643 | 66.32076 | 67.54718 |
| 132 | 55 |  0 | 0.471695 |  1.22641 |  1.4151  | 40.84906 | 55.94341 | 62.54716 | 86.13208 |
| 132 |  3 |  0 | 0.803574 | 1.339279 | 2.946426 | 18.66071 | 42.05357 | 51.78571 | 64.91071 |
| 132 | 28 |  0 | 1.037735 |  2.07547 |  4.05661 | 23.49057 | 47.35849 | 57.73586 | 75.37737 |
| 132 |  5 |  0 | 0.535721 | 1.160721 | 1.964294 | 29.46429 |  33.125  | 62.05357 | 78.92857 |
| 132 | 21 |  0 | 0.446426 |   0.625  | 1.071426 | 40.26785 | 48.92857 | 59.91071 |   73.75  |
| 132 | 30 |  0 | 1.603775 |  2.45282 | 4.622635 | 35.75471 | 47.73584 | 56.03773 | 86.13206 |
| 132 |  5 |  0 | 0.357147 |   0.625  | 0.892853 | 44.01785 | 50.26785 | 52.41071 | 73.83928 |
| 132 | 50 |  0 |  0.84906 | 1.509445 |  2.54718 | 43.67924 | 52.35849 | 61.69812 | 83.39622 |
| 132 | 50 |  0 | 1.037735 | 1.886795 |  3.20755 | 37.54716 | 47.83018 | 62.16982 | 86.22641 |

# 2、对脉冲数据拟合曲线

从获得的数据里面，我们对第一帧数据绘制散点图可以得到

![image](https://s1.ax1x.com/2020/09/23/wxQCEq.png)

这里面我们首先主要考虑`多项式拟合`、`双指数拟合`两种形式：

1. 多项式拟合

```python
poly = np.polyfit(x,y,5) 
```

![多项式曲线](https://s1.ax1x.com/2020/09/23/wxY1w4.png)

2. 双指数拟合

根据论文[《FPGA-Only MVT Digitizer for TOF PET》](http://ieeexplore.ieee.org/document/6589019/)中的双指数形式：

$$y(t)=a \times \exp \left(-\frac{t-t_{0}}{b}\right) \times\left[1-\exp \left(-\frac{t-t_{0}}{d}\right)\right]$$

我们假设函数形式为：
```python
def double_exp(x,a,b,d):
    """双指数函数
    参数:
    ------------
    x : float
        当前时间与脉冲发生时间的差值
    a : float
        由脉冲幅度决定
    b, d: float
        由脉冲的上升和下降时间决定
    """
    return  a*np.exp(b*(x))*(1-np.exp(d*(x)))
```

这里面还是详细介绍双指数函数的拟合过程，拟合时使用scipy模块的子模块optimize中提供的一个专门用于曲线拟合的函数curve_fit()。
虽然是调用函数，但是在拟合的时候还是发现了几个严重的问题，其中包括参数上下限的选取以及拟合次数的选择。

```python
bounds = ([-2,-2,0],[0,0,2])
    popt, pcov = curve_fit(double_exp, x_dexp, y_dexp, bounds = bounds, maxfev=500000)
    # popt, pcov = curve_fit(double_exp, x_dexp, y_dexp, maxfev=500000)

    '''scipy模块的子模块optimize中提供的一个专门用于曲线拟合的函数curve_fit()
    # 官方详解链接：https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy-optimize-curve-fit
    # popt：阵列参数的最佳值，以使（扩展数据，*popt）-ydata平方残差之和最小。
    # pcov：二维阵列popt的估计协方差，对角线提供参数估计的方差。
    # perr = np.sqrt(np.diag(pcov))，使用perr计算参数的一个标准偏差误差。
    # bounds：参数的上下限。默认为无边界。元组的每个元素必须是长度等于参数数的数组，或者是标量（在这种情况下，所有参数的界限都是相同的）。
    # maxfev：拟合次数上限。
    '''

    print("所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt[0],popt[1],popt[2]))
```

为了调整参数范围，使用断言对参数进行观察调整

```python
def assert_popt(popt,bounds,num):
    '''检查拟合参数是否需要调整
    参数：
    --------
    popt：拟合得到的参数
    bounds：参数范围
    num：第num+1次拟合
    '''
    for i in range(3):
        assert (popt[i]!=bounds[0][i]), "参数%s下限值应该调整!!!\n第%d帧数据所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt_dict[i],num+1,popt[0],popt[1],popt[2])
        assert (popt[i]!=bounds[1][i]), "参数%s上限值应该调整!!!\n第%d帧数据所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt_dict[i],num+1,popt[0],popt[1],popt[2])
```

接着在对坐标进行插值处理后得到更加光滑的拟合曲线。

![双指数函数曲线](https://s1.ax1x.com/2020/09/27/0FeGIs.png)


# 3、计算每个脉冲事件的能量（脉冲积分）

可根据第二步中拟合出的脉冲波形所得到的脉冲函数，再对脉冲进行积分运算，求出脉冲所具有的能量。

在这里面我积分采用了三种办法：
1. 蒙特卡洛积分法。在均匀分布的条件下，求取采样值对应的函数值，乘以上下限的差，得到矩形面积，对矩形面积求平均即是积分值。但是存在误差偏大的情况。
2. integrate(函数，（变量，下限， 上限）)。但是无法对指数函数积分
3. 使用Scipy下的integrate.quad()函数，只需给出函数的形式以及积分上下限，便可返回积分值与误差。

最终采用第三种办法，并利用xlwt库函数将积分值保存至`Excel`中，得到下表结果

|  nB | nC | T1 |    T2    |    T3    |    T4    |    T5    |    T6    |    T7    |    T8    |  Energy  |
|:---:|:--:|:--:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 132 | 36 |  0 |  0.28302 | 0.943405 |  1.69812 | 37.64151 | 51.22643 | 66.32076 | 67.54718 | 22804.16 |
| 132 | 55 |  0 | 0.471695 |  1.22641 |  1.4151  | 40.84906 | 55.94341 | 62.54716 | 86.13208 | 26281.84 |
| 132 |  3 |  0 | 0.803574 | 1.339279 | 2.946426 | 18.66071 | 42.05357 | 51.78571 | 64.91071 | 12758.97 |
| 132 | 28 |  0 | 1.037735 |  2.07547 |  4.05661 | 23.49057 | 47.35849 | 57.73586 | 75.37737 | 14829.62 |
| 132 |  5 |  0 | 0.535721 | 1.160721 | 1.964294 | 29.46429 |  33.125  | 62.05357 | 78.92857 | 16092.16 |
| 132 | 21 |  0 | 0.446426 |   0.625  | 1.071426 | 40.26785 | 48.92857 | 59.91071 |   73.75  | 29224.47 |
| 132 | 30 |  0 | 1.603775 |  2.45282 | 4.622635 | 35.75471 | 47.73584 | 56.03773 | 86.13206 | 18263.02 |
| 132 |  5 |  0 | 0.357147 |   0.625  | 0.892853 | 44.01785 | 50.26785 | 52.41071 | 73.83928 | 38517.08 |
| 132 | 50 |  0 |  0.84906 | 1.509445 |  2.54718 | 43.67924 | 52.35849 | 61.69812 | 83.39622 | 25921.93 |
| 132 | 50 |  0 | 1.037735 | 1.886795 |  3.20755 | 37.54716 | 47.83018 | 62.16982 | 86.22641 | 20565.32 |

这里面最关键的还是积分值的`准确性`的问题。




# 4、画出事件能谱

在对绘制事件能谱前，考虑到需要对数据进行清洗，由于拟合失败，积分值中存在极少数一部分小于1000的不符合逻辑的积分值，我们考虑利用整个事件的能谱平均值进行代替。

同时为了对积分情况进行检验，编写了integrate_debug.py文件

可以利用生成的.xls文件对`65000`个能量积分值进行绘制直方图。

也可以直接将能量积分值追加列表绘制直方图。

# 5、对能谱归一化

对能谱$S(t)$来说，设其中的最大值为$S_{max}$利用线性标准化进行归一化到511kev即：

$$S(t)_{normal} = S(t)\frac{511}{S_{max}}$$


在归一化后可以得到事件能谱图如下：

[![能谱直方图](https://s1.ax1x.com/2020/09/27/0FnpnO.png)](https://imgchr.com/i/0FnpnO)


# 6、高斯拟合

使用高斯拟合函数进行拟合，可能存在单高斯、双高斯以及多高斯的情况。

这里面我们采取双高斯函数
```python
def gaussian_2(x,*param):
    return param[0]*np.exp(-np.power(x - param[2], 2.) / (2 * np.power(param[4], 2.)))+\
           param[1]*np.exp(-np.power(x - param[3], 2.) / (2 * np.power(param[5], 2.)))
```

由于取的点较少，只有5000帧，得到的高斯拟合图像如图所示，且目前正在优化

[![高斯拟合图像](https://s1.ax1x.com/2020/09/27/0Fn14s.png)](https://imgchr.com/i/0Fn14s)

# 7、计算能量分辨率
探测器的能量分辨率（Energy resolution of a detector)，表示线性探测器区分被探测粒子能量的能力的一个量。能量分辨率的分子是全能峰的半宽度，分母是全能峰能量的期望值。

它可用下述方法表示：利用一个发射一种或多种单能粒子的辐射源照射探测器，得到包括一个或多个单能峰的能谱。该能谱中各种峰的半高宽的大小称为该探测器对这种辐射的能量分辨率。

若不能忽略除探测器以外的其它因素对半高宽的影响，则应以平方相减的方法扣除这部分的影响，求出真正的探测器的半高宽：其中<ERR>为总的半高宽，<ERR>为除探测器以外部分引起的半高宽；AEn为探测器引起的半高宽。为使所测得的半高宽结果可信，必须在所测谱线中保证半高宽所占道数大于5道。由于半高宽与辐射能量有直接关系，因此，在给定能量分辨率时必须给出所对应的辐射能量。并要保证被测辐射的能量基本上全都损耗在探测器灵敏体积内。





61.2019%


