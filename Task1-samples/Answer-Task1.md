==闪烁脉冲信号处理任务==
> 数据下载地址：链接: https://pan.baidu.com/s/1vlh6rLdmQAU_ePxIN7blDg  密码: flch
> 
> 数据的电压采样阈值为：V1=40、V2=110、V3=180、V4=270

# 1、读取二进制Samples文件

.samples文件是二进制的文件，可以使用python的BufferedIOBase.read(size: int) -> bytes函数进行读取。这里面，我们定义每一个事件为544bits，为一帧。将数据提取出来之后，利用unpack函数进行解包.

```python
struct.unpack('<hhdddddddd', binf_single)
```

![image](https://s1.ax1x.com/2020/09/23/wxQVv4.png)

由于`6BDM.samples`文件过大，所以我们只对前10帧数据进行提取,可以得到以下的数据

|  nB | nC | T1 |    T2    |    T3    |    T4    |    T5    |    T6    |    T7    |    T8    |
|:---:|:--:|:--:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 132 | 36 |  0 |  0.28302 | 0.943405 |  1.69812 | 37.64151 | 51.22643 | 66.32076 | 67.54718 |
| 132 | 55 |  0 | 0.471695 |  1.22641 |  1.4151  | 40.84906 | 55.94341 | 62.54716 | 86.13208 |
| 132 |  3 |  0 | 0.803574 | 1.339279 | 2.946426 | 18.66071 | 42.05357 | 51.78571 | 64.91071 |
| 132 | 28 |  0 | 1.037735 |  2.07547 |  4.05661 | 23.49057 | 47.35849 | 57.73586 | 75.37737 |
| 132 |  5 |  0 | 0.535721 | 1.160721 | 1.964294 | 29.46429 |  33.125  | 62.05357 | 78.92857 |
| 132 | 21 |  0 | 0.446426 |   0.625  | 1.071426 | 40.26785 | 48.92857 | 59.91071 |   73.75  |
| 132 | 30 |  0 | 1.603775 |  2.45282 | 4.622635 | 35.75471 | 47.73584 | 56.03773 | 86.13206 |
| 132 |  5 |  0 | 0.357147 |   0.625  | 0.892853 | 44.01785 | 50.26785 | 52.41071 | 73.83928 |
| 132 | 50 |  0 |  0.84906 | 1.509445 |  2.54718 | 43.67924 | 52.35849 | 61.69812 | 83.39622 |
| 132 | 50 |  0 | 1.037735 | 1.886795 |  3.20755 | 37.54716 | 47.83018 | 62.16982 | 86.22641 |

# 2、对脉冲数据拟合曲线

从获得的数据里面，我们对第一帧数据绘制散点图可以得到

![image](https://s1.ax1x.com/2020/09/23/wxQCEq.png)

这里面我们首先主要考虑`多项式拟合`、`双指数拟合`两种形式：

1. 多项式拟合

```python
poly = np.polyfit(x,y,5) 
```
![多项式曲线](https://s1.ax1x.com/2020/09/23/wxY1w4.png)

2. 双指数拟合

根据论文[《FPGA-Only MVT Digitizer for TOF PET》](http://ieeexplore.ieee.org/document/6589019/)中的双指数形式：

$$y(t)=a \times \exp \left(-\frac{t-t_{0}}{b}\right) \times\left[1-\exp \left(-\frac{t-t_{0}}{d}\right)\right]$$

我们假设函数形式为：
```python
def double_exp(x,a,b,d):
    """双指数函数
    参数:
    ------------
    x : float
        当前时间与脉冲发生时间的差值
    a : float
        由脉冲幅度决定
    b, d: float
        由脉冲的上升和下降时间决定
    """
    return  a*np.exp(b*(x))*(1-np.exp(d*(x)))
```

这里面还是详细介绍双指数函数的拟合过程，拟合时使用scipy模块的子模块optimize中提供的一个专门用于曲线拟合的函数curve_fit()。
虽然是调用函数，但是在拟合的时候还是发现了几个严重的问题，其中包括参数上下限的选取以及拟合次数的选择。

```python
bounds = ([-2,-2,0],[0,0,2])
    popt, pcov = curve_fit(double_exp, x_dexp, y_dexp, bounds = bounds, maxfev=500000)
    # popt, pcov = curve_fit(double_exp, x_dexp, y_dexp, maxfev=500000)

    '''scipy模块的子模块optimize中提供的一个专门用于曲线拟合的函数curve_fit()
    # 官方详解链接：https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy-optimize-curve-fit
    # popt：阵列参数的最佳值，以使（扩展数据，*popt）-ydata平方残差之和最小。
    # pcov：二维阵列popt的估计协方差，对角线提供参数估计的方差。
    # perr = np.sqrt(np.diag(pcov))，使用perr计算参数的一个标准偏差误差。
    # bounds：参数的上下限。默认为无边界。元组的每个元素必须是长度等于参数数的数组，或者是标量（在这种情况下，所有参数的界限都是相同的）。
    # maxfev：拟合次数上限。
    '''

    print("所得双指数函数形式为：%f*exp(%f*(x))*(1-exp(%f*(x)))"%(popt[0],popt[1],popt[2]))
```

接着在对坐标进行插值处理后得到更加光滑的拟合曲线。
![双指数函数曲线](https://s1.ax1x.com/2020/09/27/0FeGIs.png)


# 3、计算每个脉冲事件的能量（脉冲积分）

可根据第二步中拟合出的脉冲波形所得到的脉冲函数，再对脉冲进行积分运算，求出脉冲所具有的能量。

在这里面我积分采用了三种办法：
1. 蒙特卡洛积分法。在均匀分布的条件下，求取采样值对应的函数值，乘以上下限的差，得到矩形面积，对矩形面积求平均即是积分值。但是存在误差偏大的情况。
2. integrate(函数，（变量，下限， 上限）)。但是无法对指数函数积分
3. 使用Scipy下的integrate.quad()函数，只需给出函数的形式以及积分上下限，便可返回积分值与误差。

最终采用第三种办法，并将积分值保存至Excel中，得到下表结果

|  nB | nC | T1 |    T2    |    T3    |    T4    |    T5    |    T6    |    T7    |    T8    |  Energy  |
|:---:|:--:|:--:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 132 | 36 |  0 |  0.28302 | 0.943405 |  1.69812 | 37.64151 | 51.22643 | 66.32076 | 67.54718 | 22804.16 |
| 132 | 55 |  0 | 0.471695 |  1.22641 |  1.4151  | 40.84906 | 55.94341 | 62.54716 | 86.13208 | 26281.84 |
| 132 |  3 |  0 | 0.803574 | 1.339279 | 2.946426 | 18.66071 | 42.05357 | 51.78571 | 64.91071 | 12758.97 |
| 132 | 28 |  0 | 1.037735 |  2.07547 |  4.05661 | 23.49057 | 47.35849 | 57.73586 | 75.37737 | 14829.62 |
| 132 |  5 |  0 | 0.535721 | 1.160721 | 1.964294 | 29.46429 |  33.125  | 62.05357 | 78.92857 | 16092.16 |
| 132 | 21 |  0 | 0.446426 |   0.625  | 1.071426 | 40.26785 | 48.92857 | 59.91071 |   73.75  | 29224.47 |
| 132 | 30 |  0 | 1.603775 |  2.45282 | 4.622635 | 35.75471 | 47.73584 | 56.03773 | 86.13206 | 18263.02 |
| 132 |  5 |  0 | 0.357147 |   0.625  | 0.892853 | 44.01785 | 50.26785 | 52.41071 | 73.83928 | 38517.08 |
| 132 | 50 |  0 |  0.84906 | 1.509445 |  2.54718 | 43.67924 | 52.35849 | 61.69812 | 83.39622 | 25921.93 |
| 132 | 50 |  0 | 1.037735 | 1.886795 |  3.20755 | 37.54716 | 47.83018 | 62.16982 | 86.22641 | 20565.32 |

这里面最关键的还是积分值的`准确性`的问题。


# 4、画出事件能谱

取`10000`个能量积分值进行绘制直方图即可。

# 5、对能谱归一化

对能谱$S(t)$来说，设其中的最大值为$S_{max}$利用线性标准化进行归一化到511kev即：

$$S(t)_{normal} = S(t)\frac{511}{S_{max}}$$

由于考虑到积分值不够准确的问题，所以这里面对错误数据的筛选也是一个问题，拟采用3$\sigma$原则。

在归一化后可以得到事件能谱图如下：
[![能谱直方图](https://s1.ax1x.com/2020/09/27/0FnpnO.png)](https://imgchr.com/i/0FnpnO)


# 6、高斯拟合

使用多高斯拟合函数进行拟合

```python
def gaussian(x,*param):
    return param[0]*np.exp(-np.power(x - param[2], 2.) / (2 * np.power(param[4], 2.)))+\
           param[1]*np.exp(-np.power(x - param[3], 2.) / (2 * np.power(param[5], 2.)))
```

由于取的点较少，只有5000帧，得到的高斯拟合图像如图所示，且目前正在优化

[![高斯拟合图像](https://s1.ax1x.com/2020/09/27/0Fn14s.png)](https://imgchr.com/i/0Fn14s)

# 7、计算能量分辨率




61.2019%


